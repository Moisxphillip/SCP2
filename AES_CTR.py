import math
import random
import sys
import hashlib #used for SHA-3 hash function
if (sys.version_info < (3, 6)):
    import sha3 #used for SHA-3 hash function in older systems

#_______________________________ Global Variables
KeyLength = 16 #Value in bytes
EncryptionRounds = 10
FwSbox = [0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
          0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
          0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
          0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
          0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
          0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
          0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
          0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
          0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
          0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
          0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
          0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
          0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
          0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
          0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
          0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]
InvSbox =[0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
          0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
          0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
          0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
          0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
          0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
          0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
          0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
          0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
          0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
          0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
          0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
          0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
          0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
          0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
          0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,]
BytesSbox = bytearray(FwSbox)
BytesInvSbox = bytearray(InvSbox)


PassTest = [0x00, 0x01, 0x02, 0x03,#REMOVE
         0x04, 0x05, 0x06, 0x07,
         0x08, 0x09, 0x0A, 0x0B,
         0x0C, 0x0D, 0x0E, 0x0F]
PassBytes = bytearray(PassTest)#REMOVE
#_______________________________Main Function
def main():

    String = input("Let's test the main routines: ")

    Data = TextToBytes(String)
    print(Data.hex())

    Data = Encrypt(Data, PassBytes)
    print(Data.hex())

    Data = Decrypt(Data, PassBytes)
    print(Data.hex())

    Content = BytesToText(Data)
    print(Content)


#_______________________________
def BytesToMatrix(Bytes):
    Matrix = []
    for i in range(16):
        if i % 4 == 0:
            Matrix.append([Bytes[i]])
        else:
            Matrix[i // 4].append(Bytes[i])
    return Matrix

#_______________________________
def MatrixToBytes(Matrix):
    Bytes = bytearray(16)
    for i in range(4):
        for j in range(4):
            Bytes[i*4+j] = Matrix[i][j]
    return Bytes

#_______________________________
def SubBytes(Block, Reference):
    Result = bytearray(16)
    for i in range(len(Block)):
        Result[i] = Reference[Block[i]]
    return Result

#_______________________________
def ShiftRows(Block):
    Result = bytearray(16) #Empty array for keeping the result
    for i in range(4):
        for j in range(4):
            Result[i*4 + j] = Block[i*4 + ((j+i)%4)] #shifts them jumping positions by index
    return Result

#_______________________________
def MultX2(Value):
    Result = Value << 1
    Result &= 0xff
    if (Value & 128) != 0:
        Result = Result ^ 0x1b
    return Result

#_______________________________
def MultX3(Value):
    return MultX2(Value) ^ Value

#_______________________________
def SingleMix(Column):
    Result = [MultX2(Column[0]) ^ MultX3(Column[1]) ^ Column[2] ^ Column[3], #the transformation through
              MultX2(Column[1]) ^ MultX3(Column[2]) ^ Column[3] ^ Column[0],
              MultX2(Column[2]) ^ MultX3(Column[3]) ^ Column[0] ^ Column[1],
              MultX2(Column[3]) ^ MultX3(Column[0]) ^ Column[1] ^ Column[2],]
    return Result

#_______________________________
def MixColumns(Data):
    ResultMatrix = [[], [], [], []] #Empty for collecting stuff
    for i in range(4):
        Column = [Data[j][i] for j in range(4)]
        Column = SingleMix(Column)
        for i in range(4):
            ResultMatrix[i].append(Column[i]) #Prepare processed result
    return ResultMatrix


#_______________________________
def AddRoundKeys(Block, Key):
    for i in range(len(Block)):
        Block[i] = Block[i] ^ Key[i]
    return Block

#_______________________________
def BlockProcessing(Block, Key):
    for i in range(EncryptionRounds):
        Block = SubBytes(Block, BytesSbox)
        Block = ShiftRows(Block)
        if not (i == EncryptionRounds - 1): #Columns aren't mixed in the final step
            Block = MatrixToBytes(MixColumns(BytesToMatrix(Block)))#Converts for operating, Mix and turn back into Bytes
        Block = AddRoundKeys(Block, Key)
    return Block

#_______________________________
def Encrypt(Data, Key):
    i = 0 #init index for avoiding an annoying glitch
    Result = bytearray()
    while (i < len(Data)):
        Result+= bytearray(BlockProcessing(Data[i:i+16], Key)) #Treats and adds processed block to encrypted file
        i += 16 #Skips to the next 16-bytes block
    return Result

#_______________________________
def BlockReversion(Block, Key): #basically functions above but in the other direction :D
    for i in range(EncryptionRounds):
        Block = AddRoundKeys(Block, Key) #Reverses the XOR
        if not (i == 0): #Columns aren't unmixed in the first step
            for j in range(3):
                Block = MatrixToBytes(MixColumns(BytesToMatrix(Block))) #Doing it 3 times reverses it, trust me
        for j in range(3):
            Block = (ShiftRows(Block)) #number 3 is helpful again on fixing stuff
        Block = SubBytes(Block, BytesInvSbox) #The reference table is the reversed one now
    return Block

#_______________________________
def Decrypt(Data, Key):
    i = 0 #init index for avoiding an annoying glitch
    Result = bytearray()
    while (i < len(Data)):
        Temp = Data[i:i+16]
        Result+= bytearray(BlockReversion(Temp, Key))
        i += 16 #Skips to the next 16-bytes block
    return Result

#_______________________________
def Padding(Bytes):
    NeededPadding = 0x10 -(len(Bytes) % 0x10) #Calculates padding based on byte length % block size in bytes
    return Bytes + bytes([NeededPadding] * NeededPadding)

#_______________________________
def Unpadding(Bytes):
    PaddingDone = Bytes[len(Bytes) - 1]
    Bytes = Bytes[:-PaddingDone] #Cuts a distance of bytes at the end equivalent to the padding size
    return Bytes

#_______________________________
def TextToBytes(Text):
    Bytes = bytes(Text, "ISO-8859-1") #Turns text into byte array
    Bytes = Padding(Bytes) #does padding for encription integrity
    return Bytes

#_______________________________
def BytesToText(Bytes):
    Bytes = Unpadding(Bytes) #undoes padding for recovering text integrity
    Text = Bytes.decode("ISO-8859-1") #Bytes are interpreted as text again
    return Text

#_______________________________
def CalculateHash(Bytes):
    Hash = hashlib.sha3_256()
    Hash.update(Bytes)
    return Hash.hexdigest()

#_______________________________________________________________Start!
main()



#_______________________________________________________________________________________________
